# 3. DOM 이벤트 관리

- 웹 애플리케이션은 고정된 그림이 아님 (애플리케이션의 내용은 시간이 지남에 따라 변경됨)

    - 이러한 변경이 발생하게 만드는 것이 이벤트 

- 이벤트: 사용자 또는 시스템에 의해 생성되었는지 여부와 관계없이 DOM API에서 매우 중요한 부분 

## YAGNI(You aren't gonna need it, 정말 필요하다고 간주할 때까지 기능을 추가하지 마라)

- 가독성과 단순성 

    - 가장 중요한 기능에 초점을 맞춰 개발하고, 새로운 요구가 생기면 그에 따라 아키텍처를 지속적으로 발전시켜 나간다.

- xp 원칙 중 하나 

| 당신이 필요하다고 예측할 때가 아니라, 실제로 필요할 때 구현하라

## DOM 이벤트 API 

- 이벤트: 웹 애플리케이션에서 발생하는 동작 (브라우저는 사용자에게 이를 알려줘, 사용자는 어떤 방식으로든 반응할 수 있음)

    - 사용자가 트리거한 이벤트에 반응 가능 (마우스 이벤트 -클릭, 더블클릭 / 키보드 이벤트 -키다운, 키업 / 뷰 이벤트 - 크기 조정, 스크롤)

    - 시스템 자체에서도 이벤트 생성 가능 (네트워크 상태의 변화, DOM 콘텐츠가 로드될 때 발생하는 이벤트)

- 버튼 렌더링 ---> 버튼 클릭 ---> click 이벤트 전달 ---> click 이벤트 캡처 ---> click 이벤트에 반응 (기본 클릭 이벤트 라이프 사이클)

    - 이벤트에 반응하려면, 이벤트를 트리거한 DOM 요소(이벤트 핸들러로 불리는 콜백)에 연결해야 함 

- `뷰나 시스템 이벤트의 경우, 이벤트 핸들러를 window 객체에 연결해야 함`

---

## addEventListener로 핸들러 연결 

- 이벤트를 처리하는 모든 DOM 노드에 EventTarget 인터페이스를 구현 

    - 이 인터페이스의 addEventListener 메서드는 이벤트 핸들러를 DOM 노드에 추가 

- DOM에 요소가 더 이상 존재하지 않으면, 메모리 누수를 방지하고자 이벤트 리스너도 삭제해야 함 (removeEventListener를 사용)

    - 이벤트 핸들러를 제거하려면, removeEventListener 메서드에 매개변수로 전달할 수 있도록 이에 대한 참조를 유지해야 함 

## 이벤트 객체 

- 이벤트: 포인터 좌표, 이벤트 타입, 이벤트를 트리거한 요소 같은 유용한 정보가 많이 들어있음 

- 웹 애플리케이션에 전달된 모든 이벤트에는 Event 인터페이스를 구현 

    - 타입에 따라, 이벤트 객체는 Event 인터페이스를 확장하는 좀 더 구체적인 Event 인터페이스를 구현할 수 있음  

## DOM 이벤트 라이프사이클 

- `button.addEventListener('click', hanlder, false)`

    - 세 번째 매개변수: useCapture (기본값은 false)

    - 이상적으로 폭넓은 브라우저 호환성을 얻으려면 포함해야 함 

- 이벤트 객체는 트리거한 DOM 노드에서 시작해 모든 조상 노드로 올라감 (버블 단계, 이벤트 버블링)

    - Event 인터페이스의 stopPropagation 메서드를 사용해 버블 체인을 중지할 수 있음

    - 핸들러의 순서에 의존하는 경우, 코드를 유지하기 어려울 수 있음 (이벤트 위임 패턴이 유용할 수 있음)

- useCapture 매개변수를 사용해, 핸들러의 실행 순서를 반대로 할 수 있음

    - addEventListener를 호출할 때, useCapture 매개변수에 true를 사용하면 버블 단계 대신, 캡처 단계에 이벤트 핸들러를 추가한다는 것을 의미!!!

- 버블 단계에선, 핸들러가 상향식으로 처리 / 캡처 단계에서는 반대로 처리됨 

    - 목표 단계: 이벤트가 목표 요소에 도달할 때 발생 

- 시스템은 html 태그에서 핸들러 관리를 시작하고, 이벤트를 트리거한 요소를 만날 때까지 내려감

- `생성된 모든 DOM 이벤트에 대해 브라우저는 캡처 단계(top-down)를 실행한 다음, 버블 단계를 실행한다는 것`

1. 캡처 단계 = 이벤트가 html에서 목표 요소로 이동

2. 목표 단계 = 이벤트가 목표 요소에 도달

3. 버블 단계 = 이벤트가 목표 요소에서 html로 이동

## 사용자 정의 이벤트 사용 

- DOM 이벤트 API에서는 사용자 정의 이벤트 타입을 정의하고, 다른 이벤트처럼 처리할 수 있음 

- 도메인에 바인딩되고 시스템 자체에서만 발생한 DOM 이벤트를 생성할 수 있기 때문 (DOM API에서 정말 중요)

    - 로그인, 로그아웃, 리스트에 새 레코드를 생성하는 것과 같이 데이터 집합에 발생한 이벤트에 대해 이벤트 핸들러 생성 가능

- 표준과 사용자 정의 이벤트 모두에 동일한 API를 사용하는지에 주목! (addEventListener)

## 템플릿 요소 

- 프로그래밍 방식으로 DOM 노드를 생성하는 다양한 기술이 있음 

- document.createElement (코드를 읽고, 유지하기 어려움) / template 태그를 활용하자 

- template 태그는 렌더링 엔진의 '스탬프'로 사용할 수 있는 보이지 않는 태그

---

# 기본 이벤트 처리 아키텍처 

- 렌더링 엔진: 상태를 가져오고 DOM 트리를 생성하는 순수 함수를 기반으로 함 

- 새로운 상태마다 새로운 DOM 트리를 생성해 가상 DOM 알고리즘을 적용 가능 

    - '루프'에 이벤트 핸들러를 쉽게 삽입 가능 (모든 이벤트 다음에 상태를 조작한 후, 새로운 상태로 메인 렌더링 함수를 호출할 예정)

```
초기 상태 ---> 렌더링
                
새로운 상태 ---> 렌더링 ---> 이벤트 ---> (다시 새로운 상태로)
```

- 초기 상태: 비어있는 todo 리스트
- 렌더링: 사용자에게 비어있는 리스트를 표시 
- 이벤트: 사용자가 '더미 항목'이라는 새 항목을 생성 
- 새로운 상태: 하나의 항목을 가진 todo 리스트 
- 렌더링: 사용자에게 하나의 항목을 가진 리스트를 표시
- 이벤트: 사용자가 항목을 삭제 
- 새로운 상태: 비어있는 todo 리스트 
- 렌더링: 사용자에게 비어있는 리스트를 표시

- 이벤트는 상태를 수정하고, 새로운 렌더링을 수동으로 호출하는 아주 간단한 함수

    - 실제 애플리케이션에선, 개발자가 핸들러를 빠르게 추가하고 새로운 렌더링 주기를 자동으로 호출하는 데 도움이 되는 일종의 이벤트 레지스트리를 생성하는 것이 좋음 

    