# 상태 관리 

- 모든 종류의 클라이언트 애플리케이션(웹, 데스크톱, 모바일)의 효과적인 데이터 관리 방법을 의미 

- 상태 관리는 새로운 문제를 해결하지 못함 

- 상태 관리 코드에 적합한 아키텍처의 선택 = 애플리케이션을 건강하게 유지 관리하는 데 중요 

## Model - View - Controller

- 상태를 컨트롤러에서 유지하는 것은 상태 관리의 좋은 방법이 아님 

- 불변 상태를 사용해 데이터를 전송하면, 이 API의 소비자는 상태를 조작하는 데 공개 메서드를 사용해야 함 

- 비즈니스 로직이 Model 객체에 완전히 포함되어 있으면, 애플리케이션의 다른 부분에 흩어지지 않음 

    - 상태 관리 코드를 코드베이스 수명기간 동안 높은 수준의 테스트 가능성으로 유지하는 데 도움이 됨

- MVC는 클라이언트 애플리케이션의 상태 관리에 사용된 첫 번째 패턴 중 하나 

- 1. 컨트롤러는 모델에서 초기 상태를 가져온다 

- 2. 컨트롤러는 뷰를 호출해 초기 상태를 렌더링

- 3. 시스템이 사용자 입력을 받을 준비가 됨 

- 4. 사용자가 어떤 동작을 수행함 

- 5. 컨트롤러는 올바른 Model 메서드로 사용자의 동작과 매핑

- 6. 모델이 상태를 업데이트함 

- 7. 컨트롤러는 모델에서 새로운 상태를 얻음 

- 8. 컨트롤러는 뷰를 호출해 새로운 상태를 렌더링함 

- 9. 시스템이 사용자 입력을 받을 준비가 됨 

- 렌더링과 사용자 동작 사이의 루프 = 렌더링 주기 

## 옵저버블 모델 

- 사용자가 동작을 수행할 때마다, Render 메서드를 수동으로 호출해야 하기 때문

    - 모델과 컨트롤러 간의 통합이 완벽하지 않음 

- 왜 최적의 솔루션이 아닌가?

    - 1. 상태 변경 후에 렌더링을 수동으로 호출하는 방법은 오류가 발생하기 쉬운 접근 방식 

    - 2. 동작이 상태를 변경하지 않을 때에도 render 메소드가 호출됨

- 관찰자 패턴을 기반으로 하는 모델에서 해결됨 

- Observable 모델

    - 모델의 공개 인터페이스를 수정하지 않고, 컨트롤러에 새로운 기능을 추가하는 데 유용 

    - 애플리케이션이 시작될 때, 컨트롤러는 스토리지에서 초기 데이터를 로드할 수 있음 

- 옵저버블 모델 없이, 동일한 기능을 구현하기는 어렵고 유지 관리도 힘듬 

    - 컨트롤러가 모델과 밀접하게 결합된다면, 이 패턴을 고려하는 게 좋음 

- 실제 시나리오에서 '모델'은 애플리케이션의 다른 도메인을 관리하는 Model 객체의 모음 

## 반응형 프로그래밍 

- 반응형 패러다임의 구현 = 애플리케이션이 모델 변경, HTTP 요청, 사용자 동작, 탐색 등과 같은 이벤트를 방출할 수 있는 옵저버블로 동작하도록 구현하는 것 

| 자신의 코드에서 여러 옵저버블을 사용하고 있다면, 이미 반응형 패러다임으로 작업하고 있는 것 

- 옵저버블 팩토리의 코드 = 다소 모호해 보이지만 기능은 매우 단순 

    - Model 객체의 프록시를 생성하면 여기서 원본 모델의 모든 메서드는 원본 메서드를 래핑하고, 리스너를 호출하는 동일한 이름의 새로운 메서드를 생성함 

    - 프록시로 상태를 전달하고자 간단한 getter 함수를 사용해 모델에서 변경이 수행될 때마다 현재 상태를 가져옴 

- 반응형 상태 관리 아키텍처를 설계하는 좋은 방법 

    - 간단한 옵저버블 모델을 생성하는 것 

    - 둘 이상의 Model 객체가 필요할 때 옵저버블 팩토리 추상화를 생성 가능 

---

## 네이티브 프록시 

- JS는 Proxy 객체를 통해 프록시를 생성할 수 있는 방법 제공 (객체의 디폴트 동작을 사용자 정의 코드로 쉽게 래핑 가능)

- 기본 객체를 래핑하는 Proxy를 생성하려면, Trap 집합으로 구성된 핸들러가 필요

    - 트랩 = 기본 객체의 기본 작업을 래핑하는 방법 

- `Proxy 객체로 작업할 때는 속성을 수정하는 대신, 속성을 교체`

## 이벤트 버스 

- 이벤트 주도 아키텍처(EDA)를 구현하는 하나의 방법 

- EDA로 작업할 때 모든 상태 변경 = 시스템에서 전달된 이벤트로 나타남 

    - 이벤트 = 발생한 상황을 식별하는 이름과 이벤트 처리를 위해 의미 있는 정보를 담고 있는 페이로드로 정의됨 

### 이벤트 버스 패턴의 기본 개념 

- 애플리케이션을 구성하는 '노드'들을 연결하는 단일 객체가 모든 이벤트를 처리한다는 것 

- 이벤트가 처리되면 결과가 연결된 모든 노드로 전송됨 

- 상태 관리에 이벤트 버스를 사용하는 경우, 이벤트 처리 결과는 애플리케이션 상태의 업데이트된 버전 

### 프레임워크 없는 구현 

- 모델의 또 다른 중요한 특성 = 순수 함수 

- 순수 함수 = 반환값이 입력값에 의해서만 결정되는 함수

    - 예: Math.cos(x)와 같은 예

- 순수 함수로 설계된 모델은 새로운 상태가 모델 자체의 내부 상태가 됨 (테스트 가능성을 크게 향상시킴)

    - 상태가 업데이트가 되면, 항상 새 객체가 되므로 이 특성을 사용하면 성능을 최적화시킬 수 있음 

    - 이전 상태와 새로운 상태가 동일하면 구독자를 건너뛸 수 있음 

    - 매개변수 없이 모델을 호출하면, 애플리케이션의 초기 상태를 얻을 수 있음 








